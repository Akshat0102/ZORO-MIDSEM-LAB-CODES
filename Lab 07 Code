import numpy as np

def denoise_mrf(image: np.ndarray, pairwise_weight: int = 1, iterations: int = 5):
    rows, cols = image.shape

    def average() -> int:
        avg = 0
        for i in range(rows):
            for j in range(cols):
                avg += image[i][j]
        return avg/(rows*cols)

    def singleton(i: int, j: int, mu: int) -> int:
        return (image[i][j] - mu) ** 2
    
    def pairwise(i: int, j: int) -> int:
        pairwise = 0
        if(i != 0):
            pairwise += (image[i][j] - image[i - 1][j]) ** 2
        if(i != rows - 1):
            pairwise += (image[i][j] - image[i + 1][j]) ** 2
        if(j != 0):
            pairwise += (image[i][j] - image[i][j - 1]) ** 2
        if(j != cols - 1):
            pairwise += (image[i][j] - image[i][j + 1]) ** 2
        return pairwise

    def energy() -> int:
        E = 0
        singleton_potential = 0
        pairwise_potential = 0
        for i in range(rows):
            for j in range(cols):
                singleton_potential += singleton(i, j, average())
                pairwise_potential += pairwise_weight * pairwise(i, j)
        E = singleton_potential + pairwise_potential
        return E
    
    def partial_derivative(i: int, j: int, avg: int) -> int:
        pairwise = 0
        
        if(i != 0):
            pairwise += (image[i][j] - image[i - 1][j]) * 2
        if(i != rows - 1):
            pairwise += (image[i][j] - image[i + 1][j]) * 2
        if(j != 0):
            pairwise += (image[i][j] - image[i][j - 1]) * 2
        if(j != cols - 1):
            pairwise += (image[i][j] - image[i][j + 1]) * 2
        
        pairwise *= pairwise_weight
        singleton = 2 * (image[i][j] - avg)

        return singleton + pairwise
    
    def gradient_matrix(image: np.ndarray) -> np.ndarray:
        grad = np.zeros((rows, cols), dtype=int)
        avg = average()
        # print("Gradient Mat")
        for i in range(rows):
            for j in range(cols):
                grad[i][j] = partial_derivative(i, j, avg)
        return grad
        
    # energy_history = []
    def gradient_descent(image2: np.ndarray) -> np.ndarray:
        for i in range(iterations):
            # print("Iteration: ", i)
            # energy_history.append(energy())
            image1 = np.add(image2, gradient_matrix(image2))
            image2 = image1
            image = image2
        return image2

    return gradient_descent(image) #, energy_history)
    
    
    import numpy as np

class HopfieldNetwork:

  def __init__(self, num_neurons) :

    self.num_neurons = num_neurons
    self.weights = np.zeros((num_neurons, num_neurons))

  def train (self, input_patterns):
    rows,columns = input_patterns.shape
    for pattern in input_patterns:
      pattern = np.reshape(pattern, (self.num_neurons, 1))
      self.weights += np.dot(pattern, pattern.T) 
      np.fill_diagonal (self.weights, 0)
    self.weights = self.weights/rows

  def predict (self, input_pattern):
    
    for pattern in input_pattern:
      x = np.array(pattern)
      y = np.array(pattern)
       
      for i in range(len(y)):
        activation = np.sign(x[i]+ np.dot(y,self.weights[i]))
        if(activation  == 0):
          activation = 1
        y[i] = activation
      print("for ",x ,"output is", y)
    


import numpy as np 
class HopfieldTSPSolver:
   
  def __init__(self, cities, alpha=1, beta=1, iterations=100): 
    self.cities = cities 
    self.alpha = alpha 
    self.beta = beta 
    self.iterations = iterations 
    self.num_cities = len(cities) 
    self.weights = self._initialize_weights() 
    
  def _initialize_weights(self):
    weights = np.zeros((self.num_cities, self.num_cities)) 
    for i in range(self.num_cities): 
      for j in range(i + 1, self.num_cities): 
        dist = np.linalg.norm(self.cities[i] - self.cities[j]) 
        weights[i, j] = dist 
        weights[j, i] = dist 
      return weights 

  def solve(self): 
    state = np.random.permutation(self.num_cities) 
    for i in range(self.iterations): 
      energy = self._calculate_energy(state) 
      neighbors = self._get_neighbors(state) 
      neighbor_energies = [self._calculate_energy(n) for n in neighbors] 
      min_energy = min(neighbor_energies) 
      if min_energy < energy: 
        state = neighbors[neighbor_energies.index(min_energy)] 
    return state

  def _calculate_energy(self, state): 
    energy = 0 
    for i in range(self.num_cities):
      j = (i + 1) % self.num_cities 
      energy += self.weights[state[i], state[j]] 
    return energy

  def _get_neighbors(self, state): 
    neighbors = [] 
    for i in range(self.num_cities): 
      for j in range(i + 1, self.num_cities): 
        neighbor = np.copy(state) 
        neighbor[i], neighbor[j] = neighbor[j], neighbor[i]  
        # Basically creates a new permutation by changing 2 states
        neighbors.append(neighbor) 
      return neighbors 
